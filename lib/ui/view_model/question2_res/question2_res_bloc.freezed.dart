// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'question2_res_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$Question2ResEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() sheet,
    required TResult Function() concrete,
    required TResult Function() tilled,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function()? sheet,
    TResult? Function()? concrete,
    TResult? Function()? tilled,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? sheet,
    TResult Function()? concrete,
    TResult Function()? tilled,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(Sheet value) sheet,
    required TResult Function(Concrete value) concrete,
    required TResult Function(Tilled value) tilled,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(Sheet value)? sheet,
    TResult? Function(Concrete value)? concrete,
    TResult? Function(Tilled value)? tilled,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(Sheet value)? sheet,
    TResult Function(Concrete value)? concrete,
    TResult Function(Tilled value)? tilled,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $Question2ResEventCopyWith<$Res> {
  factory $Question2ResEventCopyWith(
          Question2ResEvent value, $Res Function(Question2ResEvent) then) =
      _$Question2ResEventCopyWithImpl<$Res, Question2ResEvent>;
}

/// @nodoc
class _$Question2ResEventCopyWithImpl<$Res, $Val extends Question2ResEvent>
    implements $Question2ResEventCopyWith<$Res> {
  _$Question2ResEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$StartedImplCopyWith<$Res> {
  factory _$$StartedImplCopyWith(
          _$StartedImpl value, $Res Function(_$StartedImpl) then) =
      __$$StartedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$StartedImplCopyWithImpl<$Res>
    extends _$Question2ResEventCopyWithImpl<$Res, _$StartedImpl>
    implements _$$StartedImplCopyWith<$Res> {
  __$$StartedImplCopyWithImpl(
      _$StartedImpl _value, $Res Function(_$StartedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$StartedImpl implements _Started {
  const _$StartedImpl();

  @override
  String toString() {
    return 'Question2ResEvent.started()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$StartedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() sheet,
    required TResult Function() concrete,
    required TResult Function() tilled,
  }) {
    return started();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function()? sheet,
    TResult? Function()? concrete,
    TResult? Function()? tilled,
  }) {
    return started?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? sheet,
    TResult Function()? concrete,
    TResult Function()? tilled,
    required TResult orElse(),
  }) {
    if (started != null) {
      return started();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(Sheet value) sheet,
    required TResult Function(Concrete value) concrete,
    required TResult Function(Tilled value) tilled,
  }) {
    return started(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(Sheet value)? sheet,
    TResult? Function(Concrete value)? concrete,
    TResult? Function(Tilled value)? tilled,
  }) {
    return started?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(Sheet value)? sheet,
    TResult Function(Concrete value)? concrete,
    TResult Function(Tilled value)? tilled,
    required TResult orElse(),
  }) {
    if (started != null) {
      return started(this);
    }
    return orElse();
  }
}

abstract class _Started implements Question2ResEvent {
  const factory _Started() = _$StartedImpl;
}

/// @nodoc
abstract class _$$SheetImplCopyWith<$Res> {
  factory _$$SheetImplCopyWith(
          _$SheetImpl value, $Res Function(_$SheetImpl) then) =
      __$$SheetImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SheetImplCopyWithImpl<$Res>
    extends _$Question2ResEventCopyWithImpl<$Res, _$SheetImpl>
    implements _$$SheetImplCopyWith<$Res> {
  __$$SheetImplCopyWithImpl(
      _$SheetImpl _value, $Res Function(_$SheetImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$SheetImpl implements Sheet {
  const _$SheetImpl();

  @override
  String toString() {
    return 'Question2ResEvent.sheet()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$SheetImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() sheet,
    required TResult Function() concrete,
    required TResult Function() tilled,
  }) {
    return sheet();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function()? sheet,
    TResult? Function()? concrete,
    TResult? Function()? tilled,
  }) {
    return sheet?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? sheet,
    TResult Function()? concrete,
    TResult Function()? tilled,
    required TResult orElse(),
  }) {
    if (sheet != null) {
      return sheet();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(Sheet value) sheet,
    required TResult Function(Concrete value) concrete,
    required TResult Function(Tilled value) tilled,
  }) {
    return sheet(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(Sheet value)? sheet,
    TResult? Function(Concrete value)? concrete,
    TResult? Function(Tilled value)? tilled,
  }) {
    return sheet?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(Sheet value)? sheet,
    TResult Function(Concrete value)? concrete,
    TResult Function(Tilled value)? tilled,
    required TResult orElse(),
  }) {
    if (sheet != null) {
      return sheet(this);
    }
    return orElse();
  }
}

abstract class Sheet implements Question2ResEvent {
  const factory Sheet() = _$SheetImpl;
}

/// @nodoc
abstract class _$$ConcreteImplCopyWith<$Res> {
  factory _$$ConcreteImplCopyWith(
          _$ConcreteImpl value, $Res Function(_$ConcreteImpl) then) =
      __$$ConcreteImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ConcreteImplCopyWithImpl<$Res>
    extends _$Question2ResEventCopyWithImpl<$Res, _$ConcreteImpl>
    implements _$$ConcreteImplCopyWith<$Res> {
  __$$ConcreteImplCopyWithImpl(
      _$ConcreteImpl _value, $Res Function(_$ConcreteImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ConcreteImpl implements Concrete {
  const _$ConcreteImpl();

  @override
  String toString() {
    return 'Question2ResEvent.concrete()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ConcreteImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() sheet,
    required TResult Function() concrete,
    required TResult Function() tilled,
  }) {
    return concrete();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function()? sheet,
    TResult? Function()? concrete,
    TResult? Function()? tilled,
  }) {
    return concrete?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? sheet,
    TResult Function()? concrete,
    TResult Function()? tilled,
    required TResult orElse(),
  }) {
    if (concrete != null) {
      return concrete();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(Sheet value) sheet,
    required TResult Function(Concrete value) concrete,
    required TResult Function(Tilled value) tilled,
  }) {
    return concrete(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(Sheet value)? sheet,
    TResult? Function(Concrete value)? concrete,
    TResult? Function(Tilled value)? tilled,
  }) {
    return concrete?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(Sheet value)? sheet,
    TResult Function(Concrete value)? concrete,
    TResult Function(Tilled value)? tilled,
    required TResult orElse(),
  }) {
    if (concrete != null) {
      return concrete(this);
    }
    return orElse();
  }
}

abstract class Concrete implements Question2ResEvent {
  const factory Concrete() = _$ConcreteImpl;
}

/// @nodoc
abstract class _$$TilledImplCopyWith<$Res> {
  factory _$$TilledImplCopyWith(
          _$TilledImpl value, $Res Function(_$TilledImpl) then) =
      __$$TilledImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$TilledImplCopyWithImpl<$Res>
    extends _$Question2ResEventCopyWithImpl<$Res, _$TilledImpl>
    implements _$$TilledImplCopyWith<$Res> {
  __$$TilledImplCopyWithImpl(
      _$TilledImpl _value, $Res Function(_$TilledImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$TilledImpl implements Tilled {
  const _$TilledImpl();

  @override
  String toString() {
    return 'Question2ResEvent.tilled()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$TilledImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() sheet,
    required TResult Function() concrete,
    required TResult Function() tilled,
  }) {
    return tilled();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function()? sheet,
    TResult? Function()? concrete,
    TResult? Function()? tilled,
  }) {
    return tilled?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? sheet,
    TResult Function()? concrete,
    TResult Function()? tilled,
    required TResult orElse(),
  }) {
    if (tilled != null) {
      return tilled();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(Sheet value) sheet,
    required TResult Function(Concrete value) concrete,
    required TResult Function(Tilled value) tilled,
  }) {
    return tilled(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(Sheet value)? sheet,
    TResult? Function(Concrete value)? concrete,
    TResult? Function(Tilled value)? tilled,
  }) {
    return tilled?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(Sheet value)? sheet,
    TResult Function(Concrete value)? concrete,
    TResult Function(Tilled value)? tilled,
    required TResult orElse(),
  }) {
    if (tilled != null) {
      return tilled(this);
    }
    return orElse();
  }
}

abstract class Tilled implements Question2ResEvent {
  const factory Tilled() = _$TilledImpl;
}

/// @nodoc
mixin _$Question2ResState {
  bool get sheet => throw _privateConstructorUsedError;
  bool get concrete => throw _privateConstructorUsedError;
  bool get Tilled => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $Question2ResStateCopyWith<Question2ResState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $Question2ResStateCopyWith<$Res> {
  factory $Question2ResStateCopyWith(
          Question2ResState value, $Res Function(Question2ResState) then) =
      _$Question2ResStateCopyWithImpl<$Res, Question2ResState>;
  @useResult
  $Res call({bool sheet, bool concrete, bool Tilled});
}

/// @nodoc
class _$Question2ResStateCopyWithImpl<$Res, $Val extends Question2ResState>
    implements $Question2ResStateCopyWith<$Res> {
  _$Question2ResStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? sheet = null,
    Object? concrete = null,
    Object? Tilled = null,
  }) {
    return _then(_value.copyWith(
      sheet: null == sheet
          ? _value.sheet
          : sheet // ignore: cast_nullable_to_non_nullable
              as bool,
      concrete: null == concrete
          ? _value.concrete
          : concrete // ignore: cast_nullable_to_non_nullable
              as bool,
      Tilled: null == Tilled
          ? _value.Tilled
          : Tilled // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$Question2ResStateImplCopyWith<$Res>
    implements $Question2ResStateCopyWith<$Res> {
  factory _$$Question2ResStateImplCopyWith(_$Question2ResStateImpl value,
          $Res Function(_$Question2ResStateImpl) then) =
      __$$Question2ResStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({bool sheet, bool concrete, bool Tilled});
}

/// @nodoc
class __$$Question2ResStateImplCopyWithImpl<$Res>
    extends _$Question2ResStateCopyWithImpl<$Res, _$Question2ResStateImpl>
    implements _$$Question2ResStateImplCopyWith<$Res> {
  __$$Question2ResStateImplCopyWithImpl(_$Question2ResStateImpl _value,
      $Res Function(_$Question2ResStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? sheet = null,
    Object? concrete = null,
    Object? Tilled = null,
  }) {
    return _then(_$Question2ResStateImpl(
      sheet: null == sheet
          ? _value.sheet
          : sheet // ignore: cast_nullable_to_non_nullable
              as bool,
      concrete: null == concrete
          ? _value.concrete
          : concrete // ignore: cast_nullable_to_non_nullable
              as bool,
      Tilled: null == Tilled
          ? _value.Tilled
          : Tilled // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$Question2ResStateImpl implements _Question2ResState {
  const _$Question2ResStateImpl(
      {required this.sheet, required this.concrete, required this.Tilled});

  @override
  final bool sheet;
  @override
  final bool concrete;
  @override
  final bool Tilled;

  @override
  String toString() {
    return 'Question2ResState(sheet: $sheet, concrete: $concrete, Tilled: $Tilled)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Question2ResStateImpl &&
            (identical(other.sheet, sheet) || other.sheet == sheet) &&
            (identical(other.concrete, concrete) ||
                other.concrete == concrete) &&
            (identical(other.Tilled, Tilled) || other.Tilled == Tilled));
  }

  @override
  int get hashCode => Object.hash(runtimeType, sheet, concrete, Tilled);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Question2ResStateImplCopyWith<_$Question2ResStateImpl> get copyWith =>
      __$$Question2ResStateImplCopyWithImpl<_$Question2ResStateImpl>(
          this, _$identity);
}

abstract class _Question2ResState implements Question2ResState {
  const factory _Question2ResState(
      {required final bool sheet,
      required final bool concrete,
      required final bool Tilled}) = _$Question2ResStateImpl;

  @override
  bool get sheet;
  @override
  bool get concrete;
  @override
  bool get Tilled;
  @override
  @JsonKey(ignore: true)
  _$$Question2ResStateImplCopyWith<_$Question2ResStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
