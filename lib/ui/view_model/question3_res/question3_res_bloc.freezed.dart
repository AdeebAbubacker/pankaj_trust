// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'question3_res_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$Question3ResEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() pipewater,
    required TResult Function() wellwater,
    required TResult Function() othersource,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function()? pipewater,
    TResult? Function()? wellwater,
    TResult? Function()? othersource,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? pipewater,
    TResult Function()? wellwater,
    TResult Function()? othersource,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(Pipewater value) pipewater,
    required TResult Function(Wellwater value) wellwater,
    required TResult Function(Othersource value) othersource,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(Pipewater value)? pipewater,
    TResult? Function(Wellwater value)? wellwater,
    TResult? Function(Othersource value)? othersource,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(Pipewater value)? pipewater,
    TResult Function(Wellwater value)? wellwater,
    TResult Function(Othersource value)? othersource,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $Question3ResEventCopyWith<$Res> {
  factory $Question3ResEventCopyWith(
          Question3ResEvent value, $Res Function(Question3ResEvent) then) =
      _$Question3ResEventCopyWithImpl<$Res, Question3ResEvent>;
}

/// @nodoc
class _$Question3ResEventCopyWithImpl<$Res, $Val extends Question3ResEvent>
    implements $Question3ResEventCopyWith<$Res> {
  _$Question3ResEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$StartedImplCopyWith<$Res> {
  factory _$$StartedImplCopyWith(
          _$StartedImpl value, $Res Function(_$StartedImpl) then) =
      __$$StartedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$StartedImplCopyWithImpl<$Res>
    extends _$Question3ResEventCopyWithImpl<$Res, _$StartedImpl>
    implements _$$StartedImplCopyWith<$Res> {
  __$$StartedImplCopyWithImpl(
      _$StartedImpl _value, $Res Function(_$StartedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$StartedImpl implements _Started {
  const _$StartedImpl();

  @override
  String toString() {
    return 'Question3ResEvent.started()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$StartedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() pipewater,
    required TResult Function() wellwater,
    required TResult Function() othersource,
  }) {
    return started();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function()? pipewater,
    TResult? Function()? wellwater,
    TResult? Function()? othersource,
  }) {
    return started?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? pipewater,
    TResult Function()? wellwater,
    TResult Function()? othersource,
    required TResult orElse(),
  }) {
    if (started != null) {
      return started();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(Pipewater value) pipewater,
    required TResult Function(Wellwater value) wellwater,
    required TResult Function(Othersource value) othersource,
  }) {
    return started(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(Pipewater value)? pipewater,
    TResult? Function(Wellwater value)? wellwater,
    TResult? Function(Othersource value)? othersource,
  }) {
    return started?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(Pipewater value)? pipewater,
    TResult Function(Wellwater value)? wellwater,
    TResult Function(Othersource value)? othersource,
    required TResult orElse(),
  }) {
    if (started != null) {
      return started(this);
    }
    return orElse();
  }
}

abstract class _Started implements Question3ResEvent {
  const factory _Started() = _$StartedImpl;
}

/// @nodoc
abstract class _$$PipewaterImplCopyWith<$Res> {
  factory _$$PipewaterImplCopyWith(
          _$PipewaterImpl value, $Res Function(_$PipewaterImpl) then) =
      __$$PipewaterImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PipewaterImplCopyWithImpl<$Res>
    extends _$Question3ResEventCopyWithImpl<$Res, _$PipewaterImpl>
    implements _$$PipewaterImplCopyWith<$Res> {
  __$$PipewaterImplCopyWithImpl(
      _$PipewaterImpl _value, $Res Function(_$PipewaterImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PipewaterImpl implements Pipewater {
  const _$PipewaterImpl();

  @override
  String toString() {
    return 'Question3ResEvent.pipewater()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PipewaterImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() pipewater,
    required TResult Function() wellwater,
    required TResult Function() othersource,
  }) {
    return pipewater();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function()? pipewater,
    TResult? Function()? wellwater,
    TResult? Function()? othersource,
  }) {
    return pipewater?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? pipewater,
    TResult Function()? wellwater,
    TResult Function()? othersource,
    required TResult orElse(),
  }) {
    if (pipewater != null) {
      return pipewater();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(Pipewater value) pipewater,
    required TResult Function(Wellwater value) wellwater,
    required TResult Function(Othersource value) othersource,
  }) {
    return pipewater(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(Pipewater value)? pipewater,
    TResult? Function(Wellwater value)? wellwater,
    TResult? Function(Othersource value)? othersource,
  }) {
    return pipewater?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(Pipewater value)? pipewater,
    TResult Function(Wellwater value)? wellwater,
    TResult Function(Othersource value)? othersource,
    required TResult orElse(),
  }) {
    if (pipewater != null) {
      return pipewater(this);
    }
    return orElse();
  }
}

abstract class Pipewater implements Question3ResEvent {
  const factory Pipewater() = _$PipewaterImpl;
}

/// @nodoc
abstract class _$$WellwaterImplCopyWith<$Res> {
  factory _$$WellwaterImplCopyWith(
          _$WellwaterImpl value, $Res Function(_$WellwaterImpl) then) =
      __$$WellwaterImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$WellwaterImplCopyWithImpl<$Res>
    extends _$Question3ResEventCopyWithImpl<$Res, _$WellwaterImpl>
    implements _$$WellwaterImplCopyWith<$Res> {
  __$$WellwaterImplCopyWithImpl(
      _$WellwaterImpl _value, $Res Function(_$WellwaterImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$WellwaterImpl implements Wellwater {
  const _$WellwaterImpl();

  @override
  String toString() {
    return 'Question3ResEvent.wellwater()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$WellwaterImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() pipewater,
    required TResult Function() wellwater,
    required TResult Function() othersource,
  }) {
    return wellwater();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function()? pipewater,
    TResult? Function()? wellwater,
    TResult? Function()? othersource,
  }) {
    return wellwater?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? pipewater,
    TResult Function()? wellwater,
    TResult Function()? othersource,
    required TResult orElse(),
  }) {
    if (wellwater != null) {
      return wellwater();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(Pipewater value) pipewater,
    required TResult Function(Wellwater value) wellwater,
    required TResult Function(Othersource value) othersource,
  }) {
    return wellwater(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(Pipewater value)? pipewater,
    TResult? Function(Wellwater value)? wellwater,
    TResult? Function(Othersource value)? othersource,
  }) {
    return wellwater?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(Pipewater value)? pipewater,
    TResult Function(Wellwater value)? wellwater,
    TResult Function(Othersource value)? othersource,
    required TResult orElse(),
  }) {
    if (wellwater != null) {
      return wellwater(this);
    }
    return orElse();
  }
}

abstract class Wellwater implements Question3ResEvent {
  const factory Wellwater() = _$WellwaterImpl;
}

/// @nodoc
abstract class _$$OthersourceImplCopyWith<$Res> {
  factory _$$OthersourceImplCopyWith(
          _$OthersourceImpl value, $Res Function(_$OthersourceImpl) then) =
      __$$OthersourceImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$OthersourceImplCopyWithImpl<$Res>
    extends _$Question3ResEventCopyWithImpl<$Res, _$OthersourceImpl>
    implements _$$OthersourceImplCopyWith<$Res> {
  __$$OthersourceImplCopyWithImpl(
      _$OthersourceImpl _value, $Res Function(_$OthersourceImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$OthersourceImpl implements Othersource {
  const _$OthersourceImpl();

  @override
  String toString() {
    return 'Question3ResEvent.othersource()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$OthersourceImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function() pipewater,
    required TResult Function() wellwater,
    required TResult Function() othersource,
  }) {
    return othersource();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function()? pipewater,
    TResult? Function()? wellwater,
    TResult? Function()? othersource,
  }) {
    return othersource?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function()? pipewater,
    TResult Function()? wellwater,
    TResult Function()? othersource,
    required TResult orElse(),
  }) {
    if (othersource != null) {
      return othersource();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(Pipewater value) pipewater,
    required TResult Function(Wellwater value) wellwater,
    required TResult Function(Othersource value) othersource,
  }) {
    return othersource(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(Pipewater value)? pipewater,
    TResult? Function(Wellwater value)? wellwater,
    TResult? Function(Othersource value)? othersource,
  }) {
    return othersource?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(Pipewater value)? pipewater,
    TResult Function(Wellwater value)? wellwater,
    TResult Function(Othersource value)? othersource,
    required TResult orElse(),
  }) {
    if (othersource != null) {
      return othersource(this);
    }
    return orElse();
  }
}

abstract class Othersource implements Question3ResEvent {
  const factory Othersource() = _$OthersourceImpl;
}

/// @nodoc
mixin _$Question3ResState {
  bool get pipewater => throw _privateConstructorUsedError;
  bool get wellwater => throw _privateConstructorUsedError;
  bool get othersource => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $Question3ResStateCopyWith<Question3ResState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $Question3ResStateCopyWith<$Res> {
  factory $Question3ResStateCopyWith(
          Question3ResState value, $Res Function(Question3ResState) then) =
      _$Question3ResStateCopyWithImpl<$Res, Question3ResState>;
  @useResult
  $Res call({bool pipewater, bool wellwater, bool othersource});
}

/// @nodoc
class _$Question3ResStateCopyWithImpl<$Res, $Val extends Question3ResState>
    implements $Question3ResStateCopyWith<$Res> {
  _$Question3ResStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? pipewater = null,
    Object? wellwater = null,
    Object? othersource = null,
  }) {
    return _then(_value.copyWith(
      pipewater: null == pipewater
          ? _value.pipewater
          : pipewater // ignore: cast_nullable_to_non_nullable
              as bool,
      wellwater: null == wellwater
          ? _value.wellwater
          : wellwater // ignore: cast_nullable_to_non_nullable
              as bool,
      othersource: null == othersource
          ? _value.othersource
          : othersource // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$Question3ResStateImplCopyWith<$Res>
    implements $Question3ResStateCopyWith<$Res> {
  factory _$$Question3ResStateImplCopyWith(_$Question3ResStateImpl value,
          $Res Function(_$Question3ResStateImpl) then) =
      __$$Question3ResStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({bool pipewater, bool wellwater, bool othersource});
}

/// @nodoc
class __$$Question3ResStateImplCopyWithImpl<$Res>
    extends _$Question3ResStateCopyWithImpl<$Res, _$Question3ResStateImpl>
    implements _$$Question3ResStateImplCopyWith<$Res> {
  __$$Question3ResStateImplCopyWithImpl(_$Question3ResStateImpl _value,
      $Res Function(_$Question3ResStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? pipewater = null,
    Object? wellwater = null,
    Object? othersource = null,
  }) {
    return _then(_$Question3ResStateImpl(
      pipewater: null == pipewater
          ? _value.pipewater
          : pipewater // ignore: cast_nullable_to_non_nullable
              as bool,
      wellwater: null == wellwater
          ? _value.wellwater
          : wellwater // ignore: cast_nullable_to_non_nullable
              as bool,
      othersource: null == othersource
          ? _value.othersource
          : othersource // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$Question3ResStateImpl implements _Question3ResState {
  const _$Question3ResStateImpl(
      {required this.pipewater,
      required this.wellwater,
      required this.othersource});

  @override
  final bool pipewater;
  @override
  final bool wellwater;
  @override
  final bool othersource;

  @override
  String toString() {
    return 'Question3ResState(pipewater: $pipewater, wellwater: $wellwater, othersource: $othersource)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Question3ResStateImpl &&
            (identical(other.pipewater, pipewater) ||
                other.pipewater == pipewater) &&
            (identical(other.wellwater, wellwater) ||
                other.wellwater == wellwater) &&
            (identical(other.othersource, othersource) ||
                other.othersource == othersource));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, pipewater, wellwater, othersource);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Question3ResStateImplCopyWith<_$Question3ResStateImpl> get copyWith =>
      __$$Question3ResStateImplCopyWithImpl<_$Question3ResStateImpl>(
          this, _$identity);
}

abstract class _Question3ResState implements Question3ResState {
  const factory _Question3ResState(
      {required final bool pipewater,
      required final bool wellwater,
      required final bool othersource}) = _$Question3ResStateImpl;

  @override
  bool get pipewater;
  @override
  bool get wellwater;
  @override
  bool get othersource;
  @override
  @JsonKey(ignore: true)
  _$$Question3ResStateImplCopyWith<_$Question3ResStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
